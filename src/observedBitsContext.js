import { createContext } from "react"

export function arrayIndexMapper(index) {
  return 1 << index % 30
}

// returns a "map" of an object with leafs mapped to bit values for
// use by context observedBits
//
// indices is an array of object keys to walk the object tree with
// generated by objectKeysToArray
//
// so { this: { key: { chain: <value>, another: <value> } } }
// is represented as { this: { key: { chain: 1, another: 2 } } }
//
// arrays are also mapped:
//
// fixed-length arrays:
// { thing: <value>, subarray: [<value>, <value>, <value>] }
// is represented as { thing: 1, subarray: [2, 4, 8] }
//
// indeterminate length arrays:
// { thing: <value>, subarray: [] }
// is represented as { thing: 1, subarray: [] }
// and the internal array is mapped with each index corresponding to a bit
export function objectMapper(indices) {
  return indices.reduce((map, item, i) => {
    if (item.reduce instanceof Function) {
      const struct = map[item[0]] || {}
      let pointer = struct
      //
      for (let idx = 1; idx < item.length; idx++) {
        if (!pointer[item[idx]]) {
          if (item[idx].reduce instanceof Function && !item[idx].length) {
            break
          }
          if (
            (idx === item.length - 2 && typeof item[idx + 1] === "number") ||
            (item[idx + 1] && typeof item[idx + 1].reduce === "function")
          ) {
            pointer[item[idx]] = []
          } else {
            pointer[item[idx]] = {}
          }
        }
        if (idx === item.length - 1) {
          pointer[item[idx]] = arrayIndexMapper(i)
        }
        pointer = pointer[item[idx]]
      }
      return {
        ...map,
        [item[0]]: struct
      }
    }
    return {
      ...map,
      [item]: arrayIndexMapper(i)
    }
  }, {})
}

// creates an ordered list of key paths for an object.
// top-level leafs are represented as strings
// nested leafs are represented using arrays containing keys
// indeterminate arrays are represented with an empty array
// so { this: { array: [], fixedarray: [1, 2, 3] }, another: 1, third: { nested: 1 } }
// becomes:
// [['this', 'array', []], ['this', 'fixedarray', 1], ['this', 'fixedarray', 2], ['this', 'fixedarray', 3], 'another',
// ['third', 'nested']]
export function objectKeysToArray(object) {
  if (!object) return []
  if (typeof object.reduce === "function") {
    return object.map((_, i) => i)
  }
  return Object.keys(object).reduce((indices, key) => {
    if (
      object[key] !== null &&
      typeof object[key] === "object" &&
      Object.keys(object[key]).length
    ) {
      return [
        ...indices,
        ...objectKeysToArray(object[key]).map(nested => [
          key,
          ...(nested.reduce instanceof Function ? nested : [nested])
        ])
      ]
    }
    if (object[key] !== null && object[key].reduce instanceof Function) {
      return [...indices, [key, []]]
    }
    return [...indices, key]
  }, [])
}

// walk an object or object map to retrieve its value
// this is used by context to compare prev/next and if they
// are different, to retrieve the bit that represents this leaf
export function objectKeyValue(map, key, throws = false, i = 0) {
  if (key.reduce instanceof Function) {
    if (i === key.length - 1) {
      // end of the key chain
      if (map[key[i]]) {
        // indeterminate array? we must match all possible updates
        if (
          map[key[i]].reduce instanceof Function &&
          map[key[i]].length === 0
        ) {
          return 0xefff
        }
      }

      // next, check for asking for an index from an indeterminate array
      // we will map each index to a bit
      if (map.reduce instanceof Function && map.length === 0) {
        return arrayIndexMapper(key[i])
      }
      if (throws) {
        if (undefined === map[key[i]]) {
          throw new Error(`Invalid key, map value does not exist: "${key[i]}"`)
        }
        if (typeof map[key] === "object") {
          throw new Error(`Invalid key, map key is not a leaf: "${key}"`)
        }
      }
      return map[key[i]]
    }
    return objectKeyValue(map[key[i]], key, throws, i + 1)
  }
  if (throws) {
    if (map[key] === undefined) {
      throw new Error(`Invalid key, map value does not exist: "${key}"`)
    }
    if (typeof map[key] === "object") {
      throw new Error(`Invalid key, map key is not a leaf: "${key}"`)
    }
  }
  return map[key]
}

export function arrayKeyValue(map, key, throws = false) {
  if (key > map.length) {
    if (throws) {
      throw new Error(`Array key out of bounds: ${key}`)
    }
    return 0
  }
  return map[key]
}

export const mapObservedBitMapper = map => (prev, next) => {
  return map.getReducer(prev, next).reduce(
    (bits, mapper, index) => {
      if (map.getValue(prev, index) !== map.getValue(next, index)) {
        return bits | map.getBits(index, true)
      }
      return bits
    },
    0,
    prev,
    next
  )
}

export function makeArrayMapper() {
  const map = {
    getReducer: (prev, next) => {
      if (prev.length > next.length) {
        return prev
      }
      return next
    },
    getValue(array, index, throws = false) {
      return arrayKeyValue(array, index, throws)
    },
    getBits(index) {
      return arrayIndexMapper(index)
    },
    context() {
      return _context
    }
  }
  const _context = createContext(null, mapObservedBitMapper(map))
  return map
}

export function makeObjectMapper(legend) {
  const _indices = objectKeysToArray(legend)
  const _map = objectMapper(_indices)
  function getValue(obj, index, throws = false) {
    const lookup = typeof index === "number" ? _indices[index] : index
    const value = objectKeyValue(obj, lookup, throws)
    if (typeof value === "number") return value
    if (throws) {
      throw new Error(
        `map did not map to an index, mapped to: ${JSON.stringify(
          value
        )} with index ${_indices[index]}`
      )
    }
    return value
  }
  const map = {
    getReducer: () => _indices,
    getValue: getValue,
    getBits(index) {
      return getValue(_map, index, true)
    },
    context() {
      return _context
    }
  }
  const _context = createContext(null, mapObservedBitMapper(map))
  return map
}
